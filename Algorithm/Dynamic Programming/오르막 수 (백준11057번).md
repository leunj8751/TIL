
문제 : <https://www.acmicpc.net/problem/11057>

##### 접근하기 :

먼저 규칙을 찾기 위해 조건에 만족하는 오르막 수를 나열해봤다.
한 자릿수에서는 에서는 0 ~ 9까지 총 10개고,
두 자릿수 부터는 00 01 02 ... 09 /  11 12 .... 19 / ...... 98 99
이렇게 진행되는데, 보면 앞자리는 0부터9까지 고정이고 뒷자리 수는 오르막 수 조건을 만족하려면 앞자리 숫자보다 커야하니
앞자리가 0일때 만족하는 경우의 수 10, 앞자리가 1일때 만족하는 경우의 수 9, 이런식으로 점점 1씩 줄어들게 된다.
그래서 두자리 수 일때 만족하는 경우의 수는 (10 + 9 + 8 + ....+ 1) 해서 55가 된다.
세 자릿수도 마찬가지로 앞자리는 0-9고정이고 뒤에 두자리가 오르막 수를 만족하게끔 하면 된다.
맨 앞자리가 0일때는 00부터 가능한 경우의 수, 1일때는 11부터 가능한 경우의 수를 찾아 더해주면 되는데, 
(00부터 가능한 오르막 수 합 + 11 부터 가능한 오르막 수 합 +...) 두 자릿수의 오르막 수 경우의 수는 이전에 계산한적이 있으니
그 값을 저장해놓고 더해주면 될것 같다.

그래서 입력받은 자리수와 각 자리수마다 앞자리(0 ~ 9) 에 따른 경우의 수를 담을 2차원 배열을 만들고,
3중 반복문을 돌려(자리수 만큼 반복 / 0 ~9 까지 반복 / 0 ~ 9 가능한 오르막 수 더하기) 식을 넣으면 되겠다고 생각했다. 

```java
public class Main {

	public static void main(String[] args) {
		
		
		Scanner sc = new Scanner(System.in);
		
		int input = sc.nextInt();
		int[][] dp = new int[input+1][10];
		int result = 0;
		
		for(int i=0; i<=9; i++) {
			dp[1][i] = 1;
		}
		
		
		for(int i=2; i<=input; i++) {
			for(int j=0; j<=9; j++) {
				int sum = 0;
				for(int k=j; k<=9; k++) {
					sum += dp[i-1][k];
				}
				dp[i][j] = sum;
			}
			
		}
		
		
		for(int i=0; i <=9; i++) {
			result += dp[input][i];
		}
		
		
		System.out.println(result%10007);
	}

}

```
이클립스에서 예시넣고 돌렸을때 다 정답이길래 됐다 싶었는데 
채점해보니 틀렸다고 나왔다.
알고보니 오버플로우 때문에 dp에 값을 넣을때 10007로 나눠서 나머지를 넣어야 한다.
`sum += dp[i-1][k]` 뒤에 `sum %= 10007`을 넣으니 정답!




